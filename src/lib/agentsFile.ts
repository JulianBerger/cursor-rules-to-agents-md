import { promises as fs } from "node:fs";
import path from "node:path";

export const GENERATED_START = "<!-- GENERATED BY cursor-rules-to-agents-md -->";
export const GENERATED_INSERT =
  "<!-- cursor-rules-to-agents-md - INSERT CUSTOM RULES BELOW -->";

export type WriteMode = "overwrite" | "append";

/**
 * Wrap generated content with required marker comments.
 */
export function wrapGeneratedContent(inner: string): string {
  const trimmed = inner.trimEnd();
  return `${GENERATED_START}\n\n${trimmed}\n\n${GENERATED_INSERT}\n`;
}

/**
 * Insert or replace the generated block within an existing AGENTS.md.
 */
export function upsertGeneratedBlock(
  existingText: string,
  wrappedGenerated: string,
): string {
  if (!hasMarkers(existingText)) {
    return appendBlock(existingText, wrappedGenerated);
  }

  const startIndex = existingText.indexOf(GENERATED_START);
  const endIndex = existingText.indexOf(GENERATED_INSERT, startIndex);
  if (startIndex === -1 || endIndex === -1) {
    return appendBlock(existingText, wrappedGenerated);
  }

  const after = existingText.slice(endIndex + GENERATED_INSERT.length);
  let replacement = wrappedGenerated;
  if (replacement.endsWith("\n") && after.startsWith("\n")) {
    replacement = replacement.slice(0, -1);
  }

  return `${existingText.slice(0, startIndex)}${replacement}${after}`;
}

/**
 * Rename an existing AGENTS.md to a timestamped backup.
 */
export async function backupFile(
  filePath: string,
  now: () => Date = () => new Date(),
): Promise<string> {
  const timestamp = formatTimestamp(now());
  const dir = path.dirname(filePath);
  const backupPath = path.join(dir, `AGENTS.${timestamp}.bak`);
  await fs.rename(filePath, backupPath);
  return backupPath;
}

/**
 * Write AGENTS.md content, respecting overwrite/append and existing markers.
 */
export async function writeAgentsFile(params: {
  outPath: string;
  content: string;
  writeMode: WriteMode;
  dryRun: boolean;
}): Promise<{ finalContent: string } | null> {
  const { outPath, content, writeMode, dryRun } = params;
  const exists = await fileExists(outPath);

  if (!exists) {
    if (dryRun) {
      return { finalContent: content };
    }
    await fs.writeFile(outPath, content, "utf8");
    return null;
  }

  const existingText = await fs.readFile(outPath, "utf8");
  const hasExistingMarkers = hasMarkers(existingText);
  const finalContent = hasExistingMarkers
    ? upsertGeneratedBlock(existingText, content)
    : writeMode === "append"
      ? appendBlock(existingText, content)
      : content;

  if (dryRun) {
    return { finalContent };
  }

  if (!hasExistingMarkers && writeMode === "overwrite") {
    await backupFile(outPath);
  }

  await fs.writeFile(outPath, finalContent, "utf8");
  return null;
}

export function hasMarkers(text: string): boolean {
  return text.includes(GENERATED_START) && text.includes(GENERATED_INSERT);
}

function appendBlock(existingText: string, wrappedGenerated: string): string {
  if (!existingText.trim()) {
    return wrappedGenerated;
  }
  const needsNewline = existingText.endsWith("\n") ? "" : "\n";
  return `${existingText}${needsNewline}\n${wrappedGenerated}`;
}

function formatTimestamp(date: Date): string {
  const pad = (value: number) => value.toString().padStart(2, "0");
  const year = date.getFullYear();
  const month = pad(date.getMonth() + 1);
  const day = pad(date.getDate());
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  const seconds = pad(date.getSeconds());
  return `${year}${month}${day}-${hours}${minutes}${seconds}`;
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.stat(filePath);
    return true;
  } catch {
    return false;
  }
}
